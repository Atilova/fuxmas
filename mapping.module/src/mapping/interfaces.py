from typing import Protocol, runtime_checkable
from pathlib import Path
from uuid import UUID

from src.mapping.enums import FileMIME
from src.mapping.entity import StrategyEntity, ExposedFileEntity


@runtime_checkable
class IFile(Protocol):
    name: str
    size: int
    extension: str

    async def read(self, chunk_size: int) -> bytes: ...

    async def seek(self, offset: int) -> None: ...


class IStorage(Protocol):
    async def exists(self, path: Path) -> bool: ...

    async def download_file(self, path: Path, name: str, file: IFile) -> Path: ...

    async def save_buffer(self, file_path: Path, buffer: bytes) -> Path: ...

    async def read_buffer(self, file_path: Path) -> tuple[bool, bytes | None]: ...

    async def delete(self, path: Path) -> bool: ...

    def get_local_filesystem_path(path: Path) -> Path: ...


class IRepository(Protocol):
    async def save(self, entity: StrategyEntity, ttl: int | None = None) -> bool: ...

    async def get(self, entity_id: UUID) -> StrategyEntity | None: ...

    async def save_exposed_file(self, entity: ExposedFileEntity, ttl: int = 0) -> bool: ...

    async def get_exposed_file(self, entity_id: UUID) -> ExposedFileEntity | None: ...

    async def delete_exposed_file(self, entity_id: UUID) -> bool: ...


class IExposeFilePort(Protocol):
    async def expose(self, file_path: Path) -> tuple[bool, UUID | None]: ...

    async def get_path(self, entity_id: UUID) -> Path: ...


class IStrategyPort(Protocol):
    async def init(self, entity: StrategyEntity, downloaded_file_path: Path) -> None: ...

    def is_supported_mime(self, mime: FileMIME) -> bool: ...
